\pdfoutput=1
\documentclass[12pt]{article}

\usepackage[toc,page]{appendix}

\usepackage[utf8]{inputenc}

\usepackage{amsthm}
\usepackage{longtable}

\newtheorem{theorem}{Theorem}
\newtheorem{lemma}[theorem]{Lemma}
\theoremstyle{definition}
\newtheorem*{definition}{Definition}

\usepackage{tikz}
\usetikzlibrary{calc}

\usepackage{enumerate}
\usepackage{enumitem}

\usepackage{etoolbox}
\AtBeginEnvironment{quote}{\small}

\usepackage{mathtools}
\DeclarePairedDelimiter{\floor}{\lfloor}{\rfloor}

\usepackage[colorlinks=true,urlcolor=blue,linkcolor=blue]{hyperref}

\begin{document}

\title{CASPaxos: Replicated State Machines without logs}

\author{Denis Rystsov\\\texttt{rystsov.denis@gmail.com}}

\maketitle

\begin{abstract}
CASPaxos is a replicated state machine (RSM) protocol, an extension of Synod. Unlike Raft and Multi-Paxos which replicate the log of commands, CASPaxos replicates state, thus avoiding associated complexity. Its symmetric peer-to-peer approach achieves optimal commit latency in wide-area networks and doesn't cause transient unavailability when any $\lfloor \frac{N-1}2 \rfloor$ of $N$ nodes crash.

This paper describes CASPaxos protocol, formally proves its safety properties, covers cluster membership change and evaluates the properties of CASPaxos-based key-value storage.
\end{abstract}

\section{Introduction}

Multi-Paxos\cite{lamport01} and Raft\cite{raft} protocols allow a collection of nodes to work as a single state machine tolerating non-byzantine failures and network issues. The protocols guarantee safety in the presence of arbitrary node crashes, message loss and out-of-order delivery; and preserve liveness when at most $\lfloor \frac{N-1}2 \rfloor$ of $N$ machines are down or disconnected.

RSMs and fault-tolerant strongly consistent (linearizable) storages are equivalent in a sense that one can be implemented via the other, and vice versa. So Multi-Paxos and Raft are widely used in the industry as a foundation of such databases as Chubby\cite{chubby}, Etcd\footnote{\href{https://github.com/coreos/etcd}{https://github.com/coreos/etcd}}, Spanner\cite{spanner}, etc.

Despite the wide adoption, there are a lot of indications that those protocols are complex. Diego Ongaro and John Ousterhout write in "In Search of an Understandable Consensus Algorithm"\cite{raft}:

\begin{quote}
In an informal survey of attendees at NSDI 2012, we found few people who were comfortable with Paxos, even among seasoned researchers. We struggled with Paxos ourselves; we were not able to understand the complete protocol until after reading several simplified explanations and designing our own alternative protocol, a process that took almost a year
\end{quote}

Google's engineers write about their experience of building a Paxos-based database in the "Paxos Made Live"\cite{chubby} paper:

\begin{quote}
Despite the existing literature in the field, building such a database proved to be non-trivial \ldots{} While Paxos can be described with a page of pseudo-code, our complete implementation contains several thousand lines of C++ code \ldots{} There are significant gaps between the description of the Paxos algorithm and the needs of a real-world system.
\end{quote}

The complexity of the RSM protocols may explain the bugs in the replication layer of the established databases. Kyle Kingsbury made a comprehensive research\footnote{\href{https://aphyr.com/tags/jepsen}{https://aphyr.com/tags/jepsen}} of the distributed consistent storages and found violations of linearizability in some version of almost every system he tested including MongoDB, Etcd, Consul, RethinkDB, VoltDB, and CockroachDB.

Besides complexity, those protocols have temporary availability problems when a leader crashes or is isolated. The "There Is More Consensus in Egalitarian Parliaments" paper\cite{epaxos} describes the negative implications of a leader-based system which are applicable both to Multi-Paxos and Raft:

\begin{quote}
Traditional Paxos variants are sensitive to both long-term and transient load spikes and network delays that increase latency at the master \ldots{} this single-master optimization can harm availability: if the master fails, the system cannot service requests until a new master is elected \ldots{} Multi-Paxos has high latency because the local replica must forward all commands to the stable leader.
\end{quote}

{\bf Contributions.} We present CASPaxos, a novel protocol for building RSM that avoids complexity and pitfalls of the log-based systems.

Multi-Paxos based system is a RSM built on top of a replicated log which treats every log entry as a command. The replicated log is composed of an array of Synod\cite{lamport01} (also known as Single Decree Paxos) instances. According to the Raft paper, its complexity comes from the composition rules:

\begin{quote}
We hypothesize that Paxos’ opaqueness derives from its choice of the single-decree subset as its foundation \ldots{} The composition rules for Multi-Paxos add significant additional complexity and subtlety.

One reason is that there is no widely agreed upon algorithm for multi-Paxos. Lamport’s descriptions are mostly about single-decree Paxos; he sketched possible approaches to multi-Paxos, but many details are missing. As a result, practical systems bear little resemblance to Paxos. Each implementation begins with Paxos, discovers the difficulties in implementing it, and then develops a significantly different architecture \ldots{} real implementations are so different from Paxos that the proofs have little value
\end{quote}

Instead of using Synod as a building block, CASPaxos extends it, so there is no composition and the associated complexity. As a result, our implementation\footnote{\href{https://github.com/gryadka/js}{https://github.com/gryadka/js}} is less than 500 lines of code.

Being just an extension of Synod, CASPaxos uses its symmetric peer-to-peer approach and automatically achieves the goals set in the EPaxos\cite{epaxos} paper: (1) optimal commit latency in the wide-area when tolerating one and two failures, under realistic conditions; (2) uniform load balancing across all replicas (thus achieving high throughput); and (3) graceful performance degradation when replicas are slow or crash.

{\bf Verification}. The formal proof is given in the appendix \ref{appendix:proof}, Tobias Schottdorf and Greg Rogers independently model checked the protocol with TLA+\footnote{\href{https://tschottdorf.github.io/single-decree-paxos-tla-compare-and-swap}{https://tschottdorf.github.io/single-decree-paxos-tla-compare-and-swap}, \href{https://medium.com/@grogepodge/tla-specification-for-gryadka-c80cd625944e}{https://medium.com/@grogepodge/tla-specification-for-gryadka-c80cd625944e}}, and the implementation was successfully tested with fault injection technique.

\section{Protocols}

We begin by briefly describing the Synod protocol from the perspective of master-master replication, followed by a step by step comparison with CASPaxos.

\subsection{Synod}

An implementation of the Synod protocol is an initializable-only-once distributed register. When several clients try to initialize it concurrently, the requests either prevent each other from continuing, or a single initialization succeeds. Once a client receives a confirmation, all the follow-up initializations must return the already chosen value.

The register belongs to the CP category of the CAP theorem\footnote{\href{https://en.wikipedia.org/wiki/CAP\_theorem}{https://en.wikipedia.org/wiki/CAP\_theorem}}, so it gives up availability when more than $\lfloor \frac{N-1}2 \rfloor$ nodes are down but always preserves consistency (safety, linearizability).

Each node in the system plays the role of client, proposer or acceptor.

\begin{description}[align=left]
  \item [Clients] initiate a request by communicating with a proposer; clients may be stateless, the system may have arbitrary numbers of clients.
  \item [Proposers] perform the initialization by communicating with acceptors. Proposers keep minimal state needed to generate unique increasing update IDs (ballot numbers), the system may have arbitrary numbers of proposers.
  \item [Acceptors] store the accepted value; the system should have $2F+1$ acceptors to tolerate $F$ failures.
\end{description}

\begin{figure}[!h]
  \centering
  \begin{tikzpicture}[y=-1cm]
    \node at (0,-0.5)[scale=0.8]{Client};
    \node at (2,-0.5)[scale=0.8]{Proposer};
    \node at (4.5,-0.5)[scale=0.8]{Acceptor A};
    \node at (6.5,-0.5)[scale=0.8]{Acceptor B};
    \node at (8.5,-0.5)[scale=0.8]{Acceptor C};
    
    \draw (0,0) -- (0,5.6);
    \draw (2,0) -- (2,5.6);
    \draw (4.5,0) -- (4.5,5.6);
    \draw (6.5,0) -- (6.5,2.05);
    \draw (8.5,0) -- (8.5,5.6);
    \draw (6.4,2.05) -- (6.6,2.05);
  
    \draw[dotted] (-0.2,0.75) -- (8.6,0.75);
    \draw[dotted] (-0.2,2.55) -- (8.6,2.55);
    \draw[dotted] (-0.2,4.05) -- (8.6,4.05);
  
    \begin{scope}[very thick]
      \draw[->] (0,0.5) -- (2,0.5) node[above, midway, scale=0.8]{set 3};
      
      \node at (1,1.6)[scale=0.8]{Propose};
      \draw[->] (2,1) -- (4.5,1);
      \draw[->] (2,1.3) -- (6.5,1.3);
      \draw[->] (2,1.6) -- (8.5,1.6);
      \draw[<-, dashed] (2,1.9) -- (4.5,1.9);
      \draw[<-, dashed] (2,2.2) -- (8.5,2.2);
  
      \node at (1,3.35)[scale=0.8]{Accept};
      \draw[->] (2,2.9) -- (4.5,2.9);
      \draw[->] (2,3.2) -- (8.5,3.2);
      \draw[<-, dashed] (2,3.5) -- (4.5,3.5);
      \draw[<-, dashed] (2,3.8) -- (8.5,3.8);
  
      \draw[<-, dashed] (0,4.3) -- (2,4.3) node[below, midway, scale=0.8]{ok};
    \end{scope}
  \end{tikzpicture}
\end{figure}

It's convenient to use tuples as ballot numbers. To generate it a proposer combines its comparable ID with a local increasing counter: (counter, ID). To compare ballot tuples, we should compare the first component of the tuples and use ID only as a tiebreaker.

When a proposer receives a conflicting message from an acceptor, it should fast-forward its counter to avoid a conflict in the future.

\subsection{CASPaxos}

An implementation of CASPaxos is a rewritable distributed register. Clients change its value by submitting side-effect free functions which take the current state as an argument and yield new as a result. Out of the concurrent requests only one can succeed, once a client gets a confirmation of the change it's guaranteed that all future states are its descendants: there exists a chain of changes linking them together.

Just like with Synod, it's a CP-system, and it requires $2F+1$ nodes to tolerate $F$ failures. Also, it uses the same roles: clients, proposers, and acceptors, and a very similar two-phase state transition mechanism.

Let's review the Synod and CASPaxos protocols step-by-step.

\begin{center}
\begin{longtable}{p{15em}|p{15em}} 
  \hline
  {\bf Synod}
  &
  {\bf CASPaxos} \\ 
  \hline
  \endfirsthead

  \endhead
  \endfoot
  \endlastfoot
  
  A client proposes the $val_0$ value to a proposer.
  &
  A client submits the $f$ change function to a proposer. \\
  
  \hline
  
  The proposer generates a ballot number, $B$, and sends "prepare" messages containing that number to the acceptors.
  &
  The proposer generates a ballot number, $B$, and sends "prepare" messages containing that number to the acceptors. \\
  
  \hline
  
  {\bf An acceptor}
  &
  {\bf An acceptor} \\[6pt]
  
  %\hline
  
  Returns a conflict if it already saw a greater ballot number.
  &
  Returns a conflict if it already saw a greater ballot number.
  \\[6pt]
  
  %\hline
  
  Persists the ballot number as a promise and returns a confirmation either with an empty value (if it hasn't accepted any value yet) or with a tuple of an accepted value and its ballot number.
  &
  Persists the ballot number as a promise and returns a confirmation either with an empty value (if it hasn't accepted any value yet) or with a tuple of an accepted value and its ballot number.
  \\[6pt]
  
  \hline

  {\bf The proposer}
  &
  {\bf The proposer} \\[6pt]
  
  %\hline

  Waits for the $F+1$ confirmations
  &
  Waits for the $F+1$ confirmations \\[6pt]
  
  %\hline
  
  If they all contain the empty value, then the proposer defines the current state as $val_0$ otherwise it picks the value of the tuple with the highest ballot number.
  &
  If they all contain the empty value, then the proposer defines the current state as $\emptyset$ otherwise it picks the value of the tuple with the highest ballot number.
  \\[6pt]
  
  %\hline
  
  Sends the current state along with the generated ballot number $B$ (an "accept" message) to the acceptors.
  &
  Applies the $f$ function to the current state and sends the result, new state, along with the generated ballot number $B$ (an "accept" message) to the acceptors.
  \\[6pt]
  
  \hline
  
  {\bf An acceptor}
  &
  {\bf An acceptor} \\[6pt]
  
  %\hline
  
  Returns a conflict if it already saw a greater ballot number.
  &
  Returns a conflict if it already saw a greater ballot number.
  \\[6pt]
  
  %\hline
  
  Erases the promise, marks the received tuple (ballot number, value) as the accepted value and returns a confirmation
  &
  Erases the promise, marks the received tuple (ballot number, value) as the accepted value and returns a confirmation
  \\[6pt]
  
  \hline

  {\bf The proposer}
  &
  {\bf The proposer} \\[6pt]

  %\hline
  
  Waits for the $F+1$ confirmations
  &
  Waits for the $F+1$ confirmations. \\[6pt]
  
  %\hline
  
  Returns the current state the client.
  &
  Returns the new state to the client. \\[6pt]
  
  \hline
\end{longtable}
\end{center}

As we see, the CASPaxos's state transition is almost identical to the Synod's initialization, and if we use
$$x \to \mbox{if}\; x = \emptyset \;\mbox{then}\; val_0\; \mbox{else}\; x$$
as the change function then it indeed becomes identical.

We may use the following change functions to turn CASPaxos into a distributed compare and set register:
\begin{itemize}
  \item To {\bf initialize} a register with $val_0$ value
  $$x \to \mbox{if}\; x = \emptyset \;\mbox{then}\; (0, val_0)\; \mbox{else}\; x$$
  
  \item To {\bf update} a register to value $val_1$ if the current version is $5$
  $$x \to \mbox{if}\; x = (5, \ast) \;\mbox{then}\; (6, val_1)\; \mbox{else}\; x$$
  
  \item To {\bf read} a value
  $$x \to x$$
\end{itemize}

With this specialization, the protocol is almost indistinguishable from Bizur\cite{bizur}.

\subsubsection{One-round trip optimization}\label{1rtt}

Since the prepare phase doesn't depend on the change function, it's possible to piggyback the next prepare message on the current accept message to reduce the number of round trips from two to one.

In this case, a proposer caches the last written value, and the clients should use that proposer to initiate the state transition to benefit from the optimization.

\subsubsection{Low-latency and high-throughput consensus across WAN deployments}

WPaxos\cite{wpaxos} paper describes how to achieve low-latency and high-throughput consensus across wide area network through object stealing. It leverages the flexible quorums\cite{fpaxos} idea to cut WAN communication costs. Since CASPaxos is an extension of Synod and supports FPaxos (see the proof in the appendix \ref{appendix:fpaxos}), it supports the WPaxos optimization too.

\subsection{Cluster membership change}

Cluster membership change is a process of changing the set of nodes executing a distributed system without violating safely and liveness properties. It's crucial to have this process because it solves two problems:

\begin{enumerate}
  \item {\it How to adjust fault tolerance properties of a system}. With time the fault tolerant requirements may change. Since a CASPaxos-based system of size $N$ tolerates up to $\lfloor \frac{N-1}2 \rfloor$ crashes, a way to increase/decrease size of a cluster is also a way to increase/decrease resiliency of the system.

  \item {\it How to replace permanently failed nodes.} CASPaxos tolerates transient failures, but the hardware tends to break, so without a replacement eventually, more than $\lfloor \frac{N-1}2 \rfloor$ nodes crash, and the system becomes unavailable. A replacement of a failed node in the $N$ nodes cluster can be modeled as a shrinkage followed by an expansion.
\end{enumerate}

The process of membership change is based on Raft's idea of joint consensus where two different configurations overlap during transitions. It allows the cluster to continue operating normally during the configuration changes.

The proof of applicability of this idea to CASPaxos is based on two observations:

\begin{itemize}
  \item {\bf Flexible quorums} It has been observed before that in a Paxos-based system the only requirement for the "prepare" and "accept" quorums is the intersection \cite{abcds}\cite{vertical}\cite{fpaxos}. For example, if the cluster size is $4$, then we may require $2$ confirmations during the "prepare" phase and $3$ during the "accept" phase.
  
  \item {\bf Network equivalence} If a change in the behavior of a Paxos-based system can be explained by delaying or omitting the messages between the nodes, then the change doesn't affect consistency because Paxos tolerates the interventions of such kind. It gives freedom in changing the system as long as the change can be modeled as a message filter on top of the unmodified system.
\end{itemize}

\subsubsection{Expansion of a cluster with an odd number of nodes}

The protocol for changing the set of acceptors from $A_1 \cdots A_{2F+1}$ to $A_1 \cdots A_{2F+2}$:
\begin{enumerate}
  \item Turn on the $A_{2F+2}$ acceptor.
  \item Connect to each proposer and update its configuration to send the "accept" messages to the $A_1 \cdots A_{2F+2}$ set of acceptors and to require $F+2$ confirmations during the "accept" phase.\label{dual}
  \item Pick any proposer and execute the identity state transition function $x \to x$.\label{rescan}
  \item Connect to each proposer and update its configuration to send "prepare" messages to the $A_1 \cdots A_{2F+2}$ set of acceptors and to require $F+2$ confirmations.
\end{enumerate}

From the perspective of the $2F+1$ nodes cluster, the second step can be explained with the network equivalence principle, so the system keeps being correct. When all proposers are modified the system also works as a $2F+2$ nodes cluster with $F+1$ "prepare" quorum and $F+2$ "accept" quorum.

After the read operation finishes the state of the cluster becomes valid from the $F+2$ perspective, so we can forget about the $F+1$ interpretation. The last step switches the system from the reduced "prepare" quorum to the regular.

The same sequence executed in the reverse order shrinks cluster with an even number of nodes.

\subsubsection{Expansion of a cluster with an even number of nodes}

The $A_1 \cdots A_{2F+2}$ to $A_1 \cdots A_{2F+3}$ extension protocol is more straightforward because we can treat a $2F+2$ nodes cluster as a $2F+3$ nodes cluster where one node had been down from the beginning:
\begin{enumerate}
  \item Connect to each proposer and update its configuration to send the prepare \& accept messages to the $A_1 \cdots A_{2f+3}$ set of acceptors.
  \item Turn on the $A_{2f+3}$ acceptor.
\end{enumerate}

It's important to notice that the procedure works based on the assumption that the $2f+3^{\mbox{th}}$ node has always been down. If a cluster gets into even configuration from an odd configuration, then it's necessary to execute identity state transition (re-scan) before the extension to avoid data loss. 

Otherwise, it's possible to sequentially replace every acceptor with an empty acceptor, lose all data and violate linearizability.

\subsubsection{Optimization}

In a key-value storage implemented as an array of independent labeled CASPaxos instances, we need to perform the \ref{rescan} step for each instance (key). It results in a rescan of all record. If the storage has $K$ keys then during the $A_1 \cdots A_{2F+1}$ to $A_1 \cdots A_{2F+2}$ transition the rescan moves $K(2F+3)$ records.

The goal of the identity state transition is to make the state of the cluster valid from the $F+2$ perspective. The alternative way to reach this state is to replicate a majority of $A_1 \cdots A_{2F+1}$ nodes for any moment after the \ref{dual} step into $A_{2F+2}$ resolving conflicts by choosing an accepted value with higher ballot number. Thus reducing the rescan cost from $K(2F+3)$ to $K(F+1)$.

A background catch-up process keeping acceptors in sync up to some recent moment may reduce the cost further to $(K-k) + k(F+1)$ where $k$ is the number of updated keys since the last moment of sync.

\subsubsection{Changing the number of proposers}

Consistency and availability properties don't depend on the number of proposers so that they can be added and removed at any time. The only caveat is the procedures like shrinkage-expansion of acceptors and deletion (\ref{deletion}) which need to update all proposers as one of the steps. Fortunately, those steps are idempotent so we so we can bring a proposer down, update the list of all proposers and on the next attempt the steps succeed.

An algorithm to remove a proposer:

\begin{enumerate}
  \item Turn off the proposer.
  \item Update the list of proposers of the GC process.
  \item Update the list of proposers of the process controlling the shrinkage-expansion of acceptors.
\end{enumerate}

An algorithm to add a proposer:

\begin{enumerate}
  \item Update the list of proposers of the process controlling the shrinkage-expansion of acceptors.
  \item Update the list of proposers of the GC process.
  \item Turn on the proposer.
\end{enumerate}

\section{A CASPaxos-based key-value storage}

The lightweight nature of CASPaxos creates new ways for designing distributed systems with complex behavior. In this section, we'll discuss a CASPaxos-based design for a key-value storage and compare a research prototype with Etcd, MongoDB and other distributed databases.

Instead of designing a key-value storage as a single RSM we represent it as a set of labeled CASPaxos instances. Gryadka\footnote{\href{https://github.com/gryadka/js}{https://github.com/gryadka/js}} is a prototype implementing this idea.

\subsection{How to delete a record}\label{deletion}

CASPaxos supports only update (change) operation so to delete a value a client should update a register with an empty value (a tombstone). The downside of this approach is the space inefficiency: even when the value is empty, the system still spends space to maintain information about the register.

The straightforward removal of this information may introduce consistency issues. Consider the following state of the acceptors.

\begin{figure}[!h]
  \centering
  \begin{tabular}{ r|r|r|r }
    & Promise & Ballot & State \\ \hline
    Acceptor A && 2 & 42 \\
    Acceptor B && 3 & $\emptyset$ \\
    Acceptor C && 3 & $\emptyset$ \\
  \end{tabular}
\end{figure}

According to the CASPaxos protocol, a read operation (implemented as $x \to x$ change function) should return $\emptyset$. However, if we decide to remove all information associated with the register and the read request hits the system during the process when the data on acceptors B and C have already gone then the outcome is $42$ which violates linearizability.

An increasing of the "accept" quorum to $2F+1$ on writing an empty value before the removal solves the problem, but it makes the system less available since it's impossible to remove a register when at least one node is down.

A multi-step removal process fixes this problem.

\begin{enumerate}
  \item On a delete request, a proposer writes a tombstone with regular $F+1$ "accept" quorum, schedules a garbage collection operation and confirms the request to a client.
  \item The garbage collection operation (in the background):\label{GC}
  \begin{enumerate}
    \item Replicates an empty value to all nodes by executing the identity transform with max quorum size ($2F+1$).\label{tombstone}
    \item Connects to each proposer, invalidates its cache associated with the removing key (see one-round trip optimization \ref{1rtt}), fast-forwards its counter to be greater than the tombstone's ballot number and increments proposer's age.
    \item Connects to each acceptor and asks it to reject messages from proposers if their age is younger than the corresponding age from the previous step.
    \item Removes the register from each acceptor if it contains the tombstone from the \ref{tombstone} step.
  \end{enumerate}
\end{enumerate}

Each step of the GC process is idempotent so if any acceptor or proposer is down the process reschedules itself.

Invalidation of the proposer's caches and the age check are necessary to eliminate the lost delete anomaly, a situation when a message delayed by a channel (or an accept message corresponding to a change of the cached value) revives a value without a causal link to the deletion event.

The update of the counters is necessary to avoid the lost update anomaly which may happen when a concurrently updated value has lesser ballot number than the tombstone's ballot number, and a reader prioritizes the tombstone over the new value.

To make the age check possible, proposers should include their age into every message they send, and acceptors should persist age per proposer set by GC process.

\subsection{Low latency}

The following properties of CASPaxos help achieve low latency:
\begin{itemize}[noitemsep]
  \item It isn't a leader-based protocol so a proposer should not forward all requests to a specific node to start executing them.
  \item Requests affecting different key-value pairs do not interfere.
  \item It uses 1RTT when the requests affecting the same key land on the same proposer.
  \item No acceptor is special, so a proposer ignores slow acceptors and proceeds as soon as quorum is reached.
  \item An ability to use user-defined functions as state transition functions reduces two steps transition process (read, modify, write) into one step process.
\end{itemize}

Let's compare Gryadka with Etcd and MongoDB to see it.

All storages were tested in the same environment. Gryadka, Etcd, and MongoDB were using three DS4\_V2 nodes configuration deployed over WAN in the Azure's\footnote{\href{https://azure.microsoft.com}{https://azure.microsoft.com}} datacenters in the "West US 2", "West Central US" and "Southeast Asia" regions.

Each node has a colocated client which in one thread in a loop was reading a value, incrementing and writing it back. All clients used their keys to avoid collisions. During the experiment latency (average duration of read-modify-write operation) was measured per each client (region).

\begin{figure}[!htb]
  \centering
  \begin{tabular}{c|r|r|r|}
  \cline{2-4}
  & \multicolumn{3}{|c|}{Latency} \\
  \cline{2-4}
  & MongoDB (3.6.1) & Etcd (3.2.13) & Gryadka (1.61.8) \\
  \hline
  \multicolumn{1}{|l|}{West US 2} & 1086 ms & 679 ms & 47 ms \\
  \hline
  \multicolumn{1}{|l|}{West Central US} & 1168 ms & 718 ms & 47 ms \\
  \hline
  \multicolumn{1}{|l|}{Southeast Asia} & 739 ms & 339 ms & 356 ms \\
  \hline
  \end{tabular}
\end{figure}

The result matches our expectation especially if we take into account delay between datacenters and the leader/leaderless nature of MongoDB, Etcd, and Gryadka.

\begin{figure}[!h]
  \centering
  \begin{tabular}{llr|}
  \cline{3-3}
  & & \multicolumn{1}{|l|}{RTT} \\
  \hline
  \multicolumn{1}{|l|}{West US 2} & \multicolumn{1}{|l|}{West Central US} & 21.8 ms\\
  \hline
  \multicolumn{1}{|l|}{West US 2} & \multicolumn{1}{|l|}{Southeast Asia} & 169 ms\\
  \hline
  \multicolumn{1}{|l|}{West Central US} & \multicolumn{1}{|l|}{Southeast Asia} & 189.2 ms\\
  \hline
  \end{tabular}
\end{figure}

The leaders of MongoDB and Etcd were in the "Southeast Asia" region so to execute an operation the "West US 2" node needs additional round trip to forward a request to the leader and to receive a response (169 ms). Then the leader needs to write the change to the majority of nodes and get confirmations (0 ms and 169 ms). Since the iteration consists of reading and writing operations, in total "West US 2" node requires at least $676 \mbox{ms} = 2 \cdot (169 \mbox{ms} + 169 \mbox{ms})$. For the "West Central US" node the estimated latency is $716.4 \mbox{ms} = 2 \cdot (169 \mbox{ms} + 189.2 \mbox{ms})$, for "Southeast Asia" it's $338 \mbox{ms} = 2 \cdot 169 \mbox{ms}$.

Gryadka doesn't forward requests so the corresponding estimated latencies are $43.6 \mbox{ms} = 2 \cdot 21.8 \mbox{ms}$, $43.6 \mbox{ms} = 2 \cdot 21.8 \mbox{ms}$ and $338 \mbox{ms} = 2 \cdot 169 \mbox{ms}$.

Network fluctuations and storage implementation details may explain the difference between estimated and measured latencies.

As we see, the underlying consensus protocol plays an essential role in the performance of the system.

\subsection{Fault-tolerance}

The EPaxos paper explains how the leader-based consensus protocols lead to cluster-wide unavailability when a leader crashes or is isolated from the cluster:

\begin{quote}
  With Multi-Paxos, or any variant that relies on a stable leader, a leader failure prevents the system from processing client requests until a new leader is elected. Although clients could direct their requests to another replica (after they time out), a replica will usually not try to become the new leader immediately
\end{quote}

CASPaxos doesn't suffer from this behavior because all of its nodes of the same role are homogeneous and when any of them is isolated it doesn't affect processes running against the others. An experimental study\footnote{\href{https://github.com/rystsov/perseus}{https://github.com/rystsov/perseus}} of distributed consistent databases with default settings during a leader isolation accident supports this a priori reasoning - all systems but Gryadka has a non-zero unavailability window.

Please avoid comparing the systems by the unavailability window because it's a configuration parameter depending on RTT between nodes\footnote{\href{https://coreos.com/etcd/docs/latest/tuning.html}{https://coreos.com/etcd/docs/latest/tuning.html}} and different databases have different defaults.

\begin{figure}[!h]
  \centering
  \begin{tabular}{|l|l|l|r|}
  \hline
  Database & Version & Protocol & Unavailability\\
  \hline
  \hline
  Gryadka & 1.61.8 & CASPaxos & $<$ 1s\\
  \hline
  CockroachDB & 1.1.3 & MultiRaft & 7s\\
  Consul & 1.0.2 & Raft & 14s\\
  Etcd & 3.2.13 & Raft & 1s\\
  RethinkDB & 2.3.6 & Raft & 17s\\
  Riak & 2.2.3 & Vertical Paxos & 8s\\
  TiDB & 1.1.0 & MultiRaft & 15s\\
  \hline
  \end{tabular}
\end{figure}

\newpage

\section{Comparison with Related Work}

CASPaxos, Raft\cite{raft} and Multi-Paxos have different trade-offs. CASPaxos replicates state on each request, so it is impractical for RSM with a heavy monolithic state. Besides that the log concept in Raft and Multi-Paxos significantly simplifies the design of efficient transactions and the catch-up procedure. CASPaxos doesn't use leader election and log. Thus it avoids associated complexity and the lack of leader increases availability and reduces latency.

CASPaxos is very similar to Bizur\cite{bizur}. The latter describes the design of key-value storage, but it doesn't support custom change functions and doesn't specify how to remove values (buckets) other than by creating tombstones.

EPaxos\cite{epaxos} is a leaderless variant of Multi-Paxos which allows concurrent execution of non-interfering commands. CASPaxos doesn't allow concurrent state transition, but in some cases, it provides comparable functionality with simpler design. For example, key-value storage with independent operations between keys can be modeled as a single EPaxos-based RSM or as storage with a CASPaxos-based RSM per key. Both systems achieve optimal commit latency, uniform load balancing across all replicas and graceful performance degradation when replicas are slow or crash.

\section{Conclusion}

CASPaxos is a replicated state machine protocol which doesn't use leader election and replicates state instead of the command log. This design decision helps to avoid availability implications of having a leader and additional complexity caused by logs. The possible applications of the protocol are key-value storages and stateful actor based services.

The indirect contributions of our work are 1) the proof of safety properties which is also applicable to the other variants of Paxos such as FPaxos, and 2) the network equivalence principle which automatically proves the preservation of properties during a transition from one configuration to another.

{\bf Acknowledgements}. We thank Tobias Schottdorf and Greg Rogers for writing TLA+ specs for CASPaxos,Ezra Hoch for finding a flaw in the draft of the deletion process \ref{deletion} and Peter Bourgon for valuable comments and suggestions.

\bibliographystyle{hunsrt}
\bibliography{bib}

\newpage

\begin{appendices}
\section{Proof}
\label{appendix:proof}

\begin{theorem} \label{th:proof}
  We want to prove that for any two acknowledged changes one is always a descendant of another.
  
  Let $\bar{E}^2$ represent a set of acknowledged events (happen on proposers when they receive at least $F+1$ confirmations during the "accept" phase), and $\to$ represent the "is a descendant" relation; then we want to demonstrate that.

  \begin{equation}
    \forall x,y \in \bar{E}^2 \;:\; x \to y \lor y \to x
  \end{equation}
\end{theorem}

\theoremstyle{definition}
\begin{definition}{\bf("is a descendant" relation)}
  What does it mean that one event is a descendant of another? Informally it means that there is a chain of state transitions leading from the state acknowledged in the initial event to the state acknowledged in the final event. Let's formalize it. We start by defining this relation between the successfully accepted message events and then expand it to $\bar{E}^2$. Accepted message events happen on acceptors, for each acknowledged message event there are at least $F+1$ accepted message events, the set of such events is denoted as $\ddot{E}^2$.

  By definition of CASPaxos, any accepted state is a function of previously accepted state, so
  
  \begin{equation} \label{eq:chain}
    \forall x \in \ddot{E}^2 \quad \exists ! f \quad \exists ! y \in \ddot{E}^2 : s(x) = f(s(y))
  \end{equation}
  
  Where $s(x)$ is a state accepted by an acceptor resulting in event $x$. When \ref{eq:chain} holds for $x$ and $y$ we write $y \sim x$ and $y = I^{-1}(x)$. Now we can define "is a descendant" relation between $\ddot{E}^2$ events as:
  
  \begin{equation}
    \forall x \in \ddot{E}^2 \; \forall x \in \ddot{E}^2 \;:\; x \to y \equiv x \sim y \lor (\exists z \in \ddot{E}^2 \;:\; x \to z \land z \to y)
  \end{equation}
  
  Let's define $x.w$ for $x \in \bar{E}^2$ as accept message events which correspond to the acknowledged change $x$. By definition, the following properties hold:
  \begin{enumerate}
    \item $\forall x \in \bar{E}^2 \; x.w \subset \ddot{E}^2$
    \item $\forall x \in \bar{E}^2 \; |x.w| >= F+1$ (we require a quorum of confirmations before acknowledging a change)
    \item $\forall x \in \bar{E}^2 \; \forall y \in x.w \;:\; s(x) = s(y)$ (accepted state and acknowledged state is the same)
  \end{enumerate}
  
  The third property allows continuing "is a descendant" relation on $\bar{E}^2$:
  
  \begin{equation}
    \forall x \in \bar{E}^2 \; \forall y \in \bar{E}^2 \;:\; x \to y \equiv (\forall a \in x.w \; \forall b \in y.w \; a \to b)
  \end{equation}
\end{definition}

\begin{lemma}
  The following statement proves the theorem \ref{th:proof}.

  \begin{equation} \label{eq:step}
    \forall x \in \bar{E}^2 \; \forall y \in \ddot{E}^2 \;:\; x.b < y.b \implies x.b \leq I^{-1}(y).b
  \end{equation}

  Where $x.b$ means a ballot number of an acknowledged or an accepted event.
\end{lemma}

\begin{proof}
  Let $z_0 := y$ and $z_{n+1} := I^{-1}(z_{n})$. By definition, ballot numbers only increase: $z_{n+1}.b < z_{n}.b$, so we can use mathematical induction and \ref{eq:step} guarantees that $\exists k \;:\; z_k.b = x.b$ meaning $s(z_k) = s(x)$. Since $z_{k+1} \sim z_k$ we proved the following statement:

  \begin{equation} \label{eq:bd}
    \forall x \in \bar{E}^2 \; \forall y \in \ddot{E}^2 \;:\; x.b < y.b \implies x \to y
  \end{equation}

  Since $\forall y \in \bar{E}^2 \; \forall z \in y.w \;:\; y.b=z.b \land s(y)=s(z)$ then \ref{eq:bd} implies

  \begin{equation}
    \forall x \in \bar{E}^2 \; \forall y \in \bar{E}^2 \;:\; x.b < y.b \implies x \to y
  \end{equation}

  By definition, $\forall x \in \bar{E}^2 \; \forall y \in \bar{E}^2 \;:\; x.b < y.b \lor y.b < x.b$ so the latter means

  \begin{equation}
    \forall x \in \bar{E}^2 \; \forall y \in \bar{E}^2 \;:\; x \to y \lor y \to x
  \end{equation}

  Which proves the theorem \ref{th:proof}.
\end{proof}

Before proving the \ref{eq:step} let's define $\ddot{E}^1$ as a set of promised events (happen on acceptors during the prepare phase) and $x.r$ for $x \in \ddot{E}^2$ as promised events corresponding to the acknowledged change $x$. By definition, the following properties hold:
\begin{enumerate}
  \item $\forall x \in \ddot{E}^2 \; x.r \subset \ddot{E}^1$
  \item $\forall x \in \ddot{E}^2 \; |x.r| >= F+1$ (we require a quorum of confirmations before staring the accept phase)
\end{enumerate}.

\begin{theorem} \label{th:proof2}
  $$\forall x \in \bar{E}^2 \; \forall y \in \ddot{E}^2 \;:\; x.b < y.b \implies x.b \leq I^{-1}(y).b$$
\end{theorem}

\begin{proof}
  Let
  
  $$N = \{z.node \;|\; z \in x.w\} \cap \{z.node \;|\; z \in y.r\}$$

  $N$ isn't empty because "prepare" quorum intersects with "accept" quorum. Let $n \in N$, and $w \equiv x.w |_n$ and $u \equiv y.r |_n$ are accepted and promised events on node $n$. By definition,

  \begin{equation}
    w.b < u.b
  \end{equation}
  
  It's true because event $w$ happened before $u$ in $n$'s timeframe since an acceptor doesn't accept messages with lesser ballot numbers than they already saw and $w.b = x.b < y.b = u.b$.

  Let $P \equiv \{ x \;|\; x \in \ddot{E}^1 \land x.node = n\}$ and each event in $P$ have the following structure:

  \begin{figure}[!h]
    \centering
    \begin{tabular}{|l|l|}
    \hline
    \multicolumn{2}{|c|}{$x \in P$}\\
    \hline
    $x.ts$ & local time on node $x.node$\\
    \hline
    $x.b$ & promise, a ballot number of last prepare message\\
    \hline
    $x.ret.b$ & a ballot number of the last accepted state\\
    \hline
    $x.ret.s$ & the last accepted state\\
    \hline
    $x.node$ & a node where $x$ was emitted\\
    \hline
    \hline
    $s(x)$ & is equal to $x.ret.s$\\
    \hline
    \end{tabular}
  \end{figure}
  
  Let $A \equiv \{ x \;|\; x \in \ddot{E}^2 \land x.node = n \}$ and each event's structure is:

  \begin{figure}[!h]
    \centering
    \begin{tabular}{|l|l|}
    \hline
    \multicolumn{2}{|c|}{$x \in A$}\\
    \hline
    $x.ts$ & local time on node $x.node$\\
    \hline
    $x.b$ & a ballot number of the last accepted state\\
    \hline
    $x.s$ & the last accepted state\\
    \hline
    $x.node$ & a node where $x$ was emitted\\
    \hline
    \hline
    $s(x)$ & is equal to $x.s$\\
    \hline
    \end{tabular}
  \end{figure}

  For $x$ in $P$, $x.ret$ is the latest accepted state, let's write it formally.

  \begin{equation} \label{eq:last}
    \forall k \in P \quad k.ret.b = \max \{ l.b \;|\;l \in A \land l.ts < k.ts \} \\
  \end{equation}

  Since $w.b < u.b$, $w \in A$ and $u \in P$

  \begin{equation}
    w \in \{ z \in A, z.ts < u.ts \}
  \end{equation}

  With combination with \ref{eq:last} it implies:

  \begin{equation} \label{eq:final}
    x.b = w.b \leq \max \{ z.b \in A, z.ts < u.ts \} = u.ret.b
  \end{equation}

  By definition a proposer picks the value with max ballot number as the current state out of quorum of promise confirmations, so:

  \begin{equation}
    I^{-1}(y).b = \max \{ z.ret.b | z \in y.r \}
  \end{equation}

  Combining with \ref{eq:final} we get:

  \begin{multline}
    x.b = w.b \leq \max \{ z \in A, z.ts < u.ts \} = \\
    = u.ret.b \leq \max \{ z.ret.b | z \in y.r \} = I^{-1}(y).b
  \end{multline}

  Which proves $x.b \leq I^{-1}(y).b$.

\end{proof}

\section{FPaxos}
\label{appendix:fpaxos}
The proof of CASPaxos \ref{appendix:proof} doesn't use the size of the promise/accept quorums, it depends only on their intersection, so the same proof proves FPaxos too.

\end{appendices}

\end{document}
